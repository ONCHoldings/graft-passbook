var fs = require('fs');
var tls = require('tls');
var cli = require('cli');
var spawn = require("child_process").spawn; 
var path = require('path'); 
var _ = require('underscore');
var crypto = require('crypto');
var node_forge = require('node-forge');
var node_zip = require('node-native-zip');
var node_forge = require('node-forge');
var shasum = crypto.createHash('sha1');
var async = require('async');
var couch_config = require('./couch_config');
var _ = require('underscore');

module.exports = {
  vars: {
    $certPath: '', // === Holds the path to the certificate
    $name: '', // === Name of the downloaded file
    $files: [], // === Holds the files to include in the .pkpass
    $JSON: {}, // === Holds the json
    $SHAs: [], // === Holds the SHAs of the $files array
    $certPass: '', // === Holds the password to the certificate
    $WWDRcertPath: '', // === Holds the path to the WWDR Intermediate certificate
    $tempPath: '/tmp/', // === Holds the path to a temporary folder
    $sError: '', // === Holds error info if an error occured
    $uniqid: null, // === Holds a autogenerated uniqid to prevent overwriting other processes pass files
    $res: null
  },
  init: function($certPath, $certPass, $JSON) {
    console.log('start constructo : ', this);
    if(typeof($JSON) !== 'undefined' && $JSON !== false) {
      this.setJSON($JSON);
    }
    if(typeof($certPass) !== 'undefined' && $certPass !== false) {
      this.setCertificatePassword($certPass);
    }
    if(typeof($certPath) !== 'undefined' && $certPath !== false) {
      this.setCertificate($certPath);
    }
  },
  // ======= ================ ======= //
  // ======= HELPER FUNCTIONS ======= //
  // ======= ================ ======= //
  helpers: {
    generateUniqueId: function() {
     return String(Math.random(1000, 5000)*100000000000000000) + "_" + new Date().valueOf();
    },
    array_merge: function() {
      var args = Array.prototype.slice.call(arguments),
      argl = args.length,
      arg,
      retObj = {},
      k = '',
      argil = 0,
      j = 0,
      i = 0,
      ct = 0,
      toStr = Object.prototype.toString,
      retArr = true;

      for (i = 0; i < argl; i++) {
        if (toStr.call(args[i]) !== '[object Array]') {
          retArr = false;
          break;
        }
      }

      if (retArr) {
        retArr = [];
        for (i = 0; i < argl; i++) {
          retArr = retArr.concat(args[i]);
        }
        return retArr;
      }

      for (i = 0, ct = 0; i < argl; i++) {
        arg = args[i];
        if (toStr.call(arg) === '[object Array]') {
          for (j = 0, argil = arg.length; j < argil; j++) {
            retObj[ct++] = arg[j];
          }
        }
        else {
          for (k in arg) {
            if (arg.hasOwnProperty(k)) {
              if (parseInt(k, 10) + '' === k) {
                retObj[ct++] = arg[k];
              }
              else {
                retObj[k] = arg[k];
              }
            }
          }
        }
      }
      return retObj;
    },
    ucwords_strtolower: function(str) {
      var str_arr = str.split(" ");
      str_res = "";
      for(var i = 0; i < str_arr.length; i++) {
        str_res += str_arr[i].charAt(0).toUpperCase() + str_arr[i].slice(1) + " ";
      }
      str_res = str_res.trim();
      return str_res;
    }
  },
  // ======= ================ ======= //
  // ======= ACTION FUNCTIONS ======= //
  // ======= ================ ======= //
  check_psclass_params: function(res) {
    res.json(this.vars);
  },
  loadDecksData: function(res) {
    couch_pw_cards.view("pw_cards/all", function(err, dl_all) {
      var res_data = {
        status: false,
        decks: [],
        msg: ''
      };
      if(!err) {
        res_data['decks'] = dl_all;
        res_data['status'] = true;
        res_data['msg'] = 'OK';
      } else {
        res_data['msg'] = 'Server error during DB query';
      }
      res.json(res_data);
    });  
  },
  startBuilder: function(id, res) {
    var me = this;
    this.vars.$res = res;
    var res_data = {
      'status': false,
      'item': null,
      'msg': '',
      'test_stack': []
    };
    couch_pw_cards.get(id, function(err, citem) {
      if(!err && citem) {
        res_data['status'] = true;
        res_data['item'] = citem;
        res_data['msg'] = "OK";
        // ==== BUILDING CODE (START)
        switch(citem.category) {
          case 'Real':
            $labelco = 'rgb(174,42,34)';
            break;
          case 'Honest':
            $labelco = 'rgb(202,113,19)';
            break;
          case 'Stable':
            $labelco = 'rgb(202,183,28)';
            break;
          case 'Active':
            $labelco = 'rgb(34,136,103)';
            break;
          case 'Ahead':
            $labelco = 'rgb(37,110,167)';
            break;
          default:
            $labelco = 'rgb(137,23,198)';
            break;
        }
        me.setCertificate(__dirname + '/assets/passdemo.p12');
        me.setCertificatePassword('pass');
        me.setWWDRcertPath(__dirname + '/assets/AppleWWDRCA.pem');
        $standardKeys = {
          'description': 'GoBe.Me-a-Meal',
          'formatVersion': 1,
          'organizationName': 'GoBe.Me',
          'passTypeIdentifier': 'pass.me.gobe.passdemo',
          'serialNumber': String(Math.random(1000, 9999)*10000000000000000),
          'teamIdentifier': '2WMG965JK8',
          'relevantDate': '2014-01-14T12:59-08:00',
          'ignoresTimeZone': true
        };
        $associatedAppKeys = [];
        $relevanceKeys = [];
        $row_tip = 'None';
        if(citem.tip != "") $row_tip = citem.tip;
        $styleKeys = {
          'eventTicket': {
            'primaryFields': [
              {
                'key': 'p1',
                'value': citem.title,
                'label': ''
              }
            ],
            'secondaryFields': [
              {
                'key': 's1',
                'value': me.helpers.ucwords_strtolower(citem.title),
                'label': 'Task'
              }
            ],
            'auxiliaryFields': [
              {
                'key': 'a1',
        				'value': 'Today',
        				'label': 'Due'
              }
            ],
            'backFields': [
              {
                'key': 'b1',
        				'value': citem.description,
        				'label': 'Instructions'
              },
              {
                'key': 'b2',
        				'value': $row_tip,
        				'label': 'Tip'
              },
              {
                'key': 'b3',
        				'value': 'GoBe.Me\n832 Folsom St\nSuite 1001\nSan Francisco, CA 94107\n\ncards@gobe.me',
        				'label': 'Contact Us',
        				'dataDetectorTypes': ['PKDataDetectorTypeLink']
              }
            ],
            'headerFields': [
              {
                'key': 'h1',
        				'value': citem.category,
        				'label': 'Be'
              }
            ]
          }
        };
        $visualAppearanceKeys = {
          'barcode': {
            'format': 'PKBarcodeFormatQR',
            'message': String(Math.random(1000, 5000)*100000000000000000),
            'messageEncoding': 'iso-8859-1'
          },
          'backgroundColor': $labelco,
          'foregroundColor': 'rgb(255,255,255)',
          'labelColor': 'rgb(21,21,21)'
        };
        $webServiceKeys = [];
        $passData = me.helpers.array_merge($standardKeys, $associatedAppKeys, $relevanceKeys, $styleKeys, $visualAppearanceKeys, $webServiceKeys);
        me.setJSON(JSON.stringify($passData));
        me.vars.$files.length = 0;
        me.addFile(__dirname + '/assets/images/icon.png');
        me.addFile(__dirname + '/assets/images/icon@2x.png');
        me.addFile(__dirname + '/assets/images/logo.png');
        me.addFile(__dirname + '/assets/images/strip.png');
        // ==== BUILDING CODE (END)
        res_data['test_stack'].push({'standardKeys': $standardKeys});
        res_data['test_stack'].push({'associatedAppKeys': $associatedAppKeys});
        res_data['test_stack'].push({'relevanceKeys': $relevanceKeys});
        res_data['test_stack'].push({'styleKeys': $styleKeys});
        res_data['test_stack'].push({'visualAppearanceKeys': $visualAppearanceKeys});
        res_data['test_stack'].push({'webServiceKeys': $webServiceKeys});
        res_data['test_stack'].push({'passData': $passData});
        res_data['test_stack'].push({'passData_string': JSON.stringify($passData)});
        res_data['test_stack'].push({'labelco': $labelco});
        console.log("TEST STACK: ", res_data['test_stack']);
      }
      res.json(res_data);
    });
  },
  startCreationProcess: function(res) {
    this.create(res, true);
  },
  // ======= ================ ======= //
  // ======= PUBLIC FUNCTIONS ======= //
  // ======= ================ ======= //
  debugVars: function() {
    console.log("certPath: ", this.vars.$certPath);
    console.log("name: ", this.vars.$name);
    console.log("files: ", this.vars.$files);
    console.log("JSON: ", this.vars.$JSON);
    console.log("SHAs: ", this.vars.$SHAs);
    console.log("certPass: ", this.vars.$certPass);
    console.log("WWDRcertPath: ", this.vars.$WWDRcertPath);
    console.log("tempPath: ", this.vars.$tempPath);
    console.log("sError: ", this.vars.$sError);
    console.log("uniqid: ", this.vars.$uniqid);
  },
  /*
	* Sets the path to a certificate
	* Parameter: string, path to certificate
	* Return: boolean, true on succes, false if file doesn't exist
	*/
  setCertificate: function($path) {
    var me = this;
    fs.exists($path, function($exists) {
      if($exists) {
        me.vars.$certPath = $path;
        console.log('Certificate file exists');
        // console.log('VARS AFTER: ', me.vars);
      } else {
        console.log('Certificate file does not exist.');
      }
    });
  },
  /*
	* Sets the certificate's password
	* Parameter: string, password to the certificate
	* Return: boolean, always true
	*/
  setCertificatePassword: function($p) {
    this.vars.$certPass = $p;
    return true;
  },
  /*
	* Sets the path to the WWDR Intermediate certificate
	* Parameter: string, path to certificate
	* Return: boolean, always true
	*/
  setWWDRcertPath: function($path) {
    this.vars.$WWDRcertPath = $path;
    return true;
  },
  /*
	* Sets the path to the temporary directory (must end with a slash)
	* Parameter: string, path to temporary directory
	* Return: boolean, true on success, false if directory doesn't exist
	*/
  setTempPath: function($path) {
    var me = this;
    fs.exists($path, function($exists) {
      if($exists) {
        me.vars.$tempPath = $path;
        console.log('VARS AFTER: ', me.vars);
      }
    });
  },
  /*
	* Decodes JSON and saves it to a variable
	* Parameter: json-string
	* Return: boolean, true on succes, false if json wasn't decodable
	*/
  setJSON: function($JSON) {
    var res = false;
    $JSON_dec = JSON.parse($JSON);
    if(_.isObject($JSON_dec)) {
      this.vars.$JSON = $JSON_dec;
      res = true;
    } else {
      this.vars.$sError = 'This is not a JSON string.';
    }
    return res;
  },
  /*
	* Adds file to the file array
	* Parameter: string, path to file
	* Parameter: string, optional, name to create file as
	* Return: boolean, true on succes, false if file doesn't exist
	*/
  addFile: function($path, $name) {
    var me = this;
    fs.exists($path, function($exists) {
      if($exists) {
        if(typeof($name) === 'undefined' || $name === null) {
          $name = path.basename($path);
        }
        var mid_obj = {
          'name': $name,
          'path': $path
        };
        me.vars.$files.push(mid_obj);
      } else {
        me.vars.$sError = "File does not exist.";
      }
    });
  },
  /*
	* Creates the actual .pkpass file
	* Parameter: boolean, if output is true, send the zip file to the browser.
	* Return: zipped .pkpass file on succes, false on failure
	*/
  create: function(res, output) {
    console.log('START PASSBOOK CREATION PROCESS');
    $paths = this.paths();
    
    // === creates and saves the json manifest
    $manifest = this.createManifest();
    console.log("CREATED MANIFEST: ", $manifest);
    if(!$manifest) {
      this.clean();
      return false;
    }
    
    // === create signature
    if(this.createSignature($manifest) == false) {
      this.clean();
      return false;
    }
    
    // === create zip
    if(this.createZip($manifest) == false) {
      this.clean();
      return false;
    }
    
    res.json(true);
  },
  /*
	* Download .pkpass file (zip archieve)
	*/
  startDownloadProcess: function(res) {
    $paths = this.paths();
    var exist_flag = fs.existsSync($paths.pkpass);
    console.log("FILE FOR DOWNLOAD : ", $paths.pkpass);
    console.log("exist_flag : ", exist_flag);
    var down_file = fs.readFileSync($paths.pkpass, 'binary');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Content-type', 'application/vnd.apple.pkpass');
    res.setHeader('Content-Length', down_file.length);
    res.setHeader('Content-Disposition', "attachment; filename='" + path.basename($paths.pkpass) + "'");
    res.download($paths.pkpass);
  },
  getName: function() {
    return this.vars.$name;
  },
  setName: function($name) {
    this.vars.$name = $name;
  },
  getError: function() {
    return this.vars.$sError;
  },
  // ======= ================= ======= //
  // ======= PRIVATE FUNCTIONS ======= //
  // ======= ================= ======= //
  /*
	* Subfunction of create()
	* This function creates the hashes for the files and adds them into a json string.
	*/
  createManifest: function() {
    this.vars.$SHAs.length = 0;
    var shasum = crypto.createHash('sha1');
    
    fs.writeFileSync(__dirname + "/assets/" + this.vars.$tempPath + this.vars.$uniqid + "/pass.json", JSON.stringify(this.vars.$JSON));
    
    shasum.update(JSON.stringify(this.vars.$JSON));
    this.vars.$SHAs.push({'pass.json': shasum.digest('hex')});
    $hasicon = false;
    if(this.vars.$files.length > 0) {
      for(var i = 0; i < this.vars.$files.length; i++) {
        if(this.vars.$files[i].name.toLowerCase() == 'icon.png') {
          $hasicon = true;
        }
        var path_content = fs.readFileSync(this.vars.$files[i].path);
        var path_content_str = path_content.toString('utf-8');
        
        var shasum = crypto.createHash('sha1');
        shasum.update(path_content_str);
        var path_name = this.vars.$files[i].name;
        var mid_tmp = {};
        mid_tmp[path_name] = shasum.digest('hex');
        this.vars.$SHAs.push(mid_tmp);
      }
      console.log("SHAs CHECK ME FINAL: ", this.vars.$SHAs);
    }
    if(!$hasicon) {
      this.vars.$sError = "Missing required icon.png file.";
      this.clean();
      return false;
    }
    $manifest = JSON.stringify(this.vars.$SHAs);
    return $manifest;
  },
  p12_file_extractor: function($paths, $manifest) {
    var p12b64 = fs.readFileSync(this.vars.$certPath).toString('base64');
    var p12Der = node_forge.util.decode64(p12b64);
    var p12Asn1 = node_forge.asn1.fromDer(p12Der);
    var p12 = node_forge.pkcs12.pkcs12FromAsn1(p12Asn1, this.vars.$certPass);
    var safe_bags = p12.safeContents[0].safeBags;
    var public_key = safe_bags[0].cert.publicKey;
    var cert = safe_bags[0].cert;
    var pem_cert = node_forge.pki.certificateToPem(cert);
    console.log(pem_cert);
    var pem_public_key = node_forge.pki.publicKeyToPem(public_key);
    console.log(pem_public_key);
    var pem_private_key = node_forge.pki.privateKeyToPem(p12.safeContents[1].safeBags[0].key);
    console.log(pem_private_key);
    // ==== sign manifest.json file using certificate (cert variable) and record result to 'signature' file (start)
    var p7 = node_forge.pkcs7.createEnvelopedData();
    p7.addRecipient(cert);
    p7.content = node_forge.util.createBuffer($manifest);
    p7.encrypt();
    var p7_pem = node_forge.pkcs7.messageToPem(p7);
    var p7 = node_forge.pkcs7.createSignedData();
    p7.addCertificate(cert);
    p7.addCertificate(cert);
    var p7_pem = node_forge.pkcs7.messageToPem(p7);
    console.log("p7_pem: ", p7_pem);
    fs.writeFileSync($paths.signature, p7_pem); 
    // ==== sign manifest.json file using certificate (cert variable) and record result to 'signature' file (end)
  },
  /*
	* Creates a signature and saves it
	* Parameter: json-string, manifest file
	* Return: boolean, true on succes, failse on failure
	*/
  createSignature: function($manifest) {
    $paths = this.paths();
    fs.writeFileSync($paths.manifest, $manifest); // === write manifest data to manifest.json file
    this.p12_file_extractor($paths, $manifest);
    return true;
  },
  /*
	* Creates .pkpass (zip archive)
	* Parameter: json-string, manifest file
	* Return: boolean, true on succes, false on failure
	*/
  createZip: function($manifest) {
    var me = this;
    $paths = this.paths();
    var archive = new node_zip();
    var tmp_add_files = this.vars.$files;
    var pass_json = __dirname + "/assets/" + this.vars.$tempPath + this.vars.$uniqid + "/pass.json";
    tmp_add_files.push({name: path.basename($paths.manifest), path: $paths.manifest});
    tmp_add_files.push({name: path.basename($paths.signature), path: $paths.signature});
    tmp_add_files.push({name: path.basename(pass_json), path: pass_json});
    archive.addFiles(tmp_add_files, function (err) {
        if (err) return console.log("err while adding files", err);
        var buff = archive.toBuffer();
        fs.writeFile($paths.pkpass, buff, function () {
            console.log("Zip archieve creation finished");
        });
    });
    return true;
  },
  paths: function() { // === declares all paths used for temporary files
    me = this;
    // ==== declare base paths
    $paths = {
      'pkpass': 'pass.pkpass',
      'signature': 'signature',
      'manifest': 'manifest.json'
    };
    
    // === if trailing slash is missing, add it
    if(this.vars.$tempPath.substr(-1) != "/") {
      this.vars.$tempPath = this.vars.$tempPath + "/";
    }
    
    // === generate a unique subfolder in the tempPath to support generating more passes at the same time without erasing/overwriting each others files
    if(this.vars.$uniqid === null) {
      this.vars.$uniqid = this.helpers.generateUniqueId();
      var check_path = __dirname + "/assets/" + this.vars.$tempPath + this.vars.$uniqid;
      fs.mkdirSync(check_path);
    }
    // ==== add temp folder path
    $paths.pkpass = __dirname + "/assets/" + this.vars.$tempPath + this.vars.$uniqid + "/" + $paths.pkpass;
    $paths.signature = __dirname + "/assets/" + this.vars.$tempPath + this.vars.$uniqid + "/" + $paths.signature;
    $paths.manifest = __dirname + "/assets/" + this.vars.$tempPath + this.vars.$uniqid + "/" + $paths.manifest;
    return $paths;
  },
  clean: function() { // === removes all temporary files
    $paths = this.paths();
    fs.unlinkSync($paths.pkpass);
    fs.unlinkSync($paths.signature);
    fs.unlinkSync($paths.manifest);
    var check_path = this.vars.$tempPath + this.vars.$uniqid;
    fs.exists(check_path, function(exists) {
      if(exists) {
        fs.rmdirSync(check_path);
      }
    });
    return true;
  }
};